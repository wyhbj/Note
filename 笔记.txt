1.JS简介：页面组成：
			html -- 结构
			css  -- 样式
			js   -- 行为
	js:JavaScript
	布兰德.艾奇
	js组成：
		ECMAScript(5.1) -- Js基本语法组成
		DOM(文档对象模型) -- 操作页面的方法
		BOM(浏览器对象模型) -- 浏览器相关的方法
	作用：页面交互，修改css样式，与服务器通信
	onclick鼠标点击事件
	alert()调用浏览器默认弹窗
	()：函数或者方法执行
	js行间：<input type="button" style="width:100px;height:100px" value="按钮" onclick="alert('你好')"/>
		优点：直接
		缺点：不方便修改，维护，扩展，复用
	内嵌js：
		优点：方便同一页面复用
		1.推荐script放在body结束标签上边
		2.放在head里，因为代码从上往下逐行解析，页面结构还没加载完，所以获取不到元素
		解决方法：window.onload=function(){
				代码写这里
			}
			window.onload
				页面加载完事件
			；：一行代码结束
	js外链：
		问题同内嵌js
		优点：任意页面可以复用
	变量
		var 变量名 = 数据；
		作用：存储数据，方便数据复用，简化代码
		变量初始化
		 	var 变量名 = 数据；
		 	声明变量
		 		var 变量名；
		 	变量赋值
		 		变量名 = 数据；
			命名规则
			 	1.可以使用字母，数字，下划线_,美元符$
			 	2.第一位不允许是数字
			 	3.不允许用关键字和保留字
			 	4.区分大小写，长度可以任意
			 建议
			 	1.语义化
			 		o - 一个对象
			 		a - 一组元素
			 		n - 数字
			 		str - 字符串
			 		arr - 数组
			 		fn - 函数
			 	2.小驼峰命名法
			 		除了首个单词，后边每个单词首字母大写
	函数
		function 函数名(){}
			 作用：
			 	和变量类似，复用代码
		匿名函数
		 	声明：
		 	1.匿名函数不能直接声明，否则会报错
		 	2.直接写在事件后边
		 	3.var fn = function(){}
		 		调用:
		 			1.事件调用
		 			2.变量名() -- fn()
		有名函数
		 	function 函数名(){}
		 		声明：
		 			1.直接声明
		 		调用：
		 			1.直接调用 -- 函数名()
		 			2.事件调用
		 		注意：函数名后不加括号，不然没点，就执行了 btn.onclick = fn;//函数不加括号，不然还没点，就执行了
 	调用浏览器控制台
		console.log()
	属性操作
		元素.style.样式名 = '值'
		属性操作操作的是行间样式，可读可写
			 		
		1.通过.的方式操作属性 console.log(div.style.width)
			如果样式名不符合命名规范，带- console.log(div.style.background-color)//报错
			解决方法：
			 	1.用['样式名']，注意要加引号 console.log(div.style['background-color'])  
			 	2.去掉-，后边单词首字母大写  console.log(div.style.backgroundColor)
		2.通过[]的方式  console.log(div.style['background-color'])
			注意：
			 复合样式，谷歌和火狐下，获取有区别
	常用属性
		 id
		 class -- className
		 style
		 innerHTML
		 	标签对中间的所有内容，包括子标签，行间属性
		 innerText
		 	标签中的文字内容，不会识别标签
		 style.cssText
	连接符+
		1.两边都是数字，进行加法运算       console.log(1+1)//2
		2.两边都是字符串，进行字符串拼接   console.log('1'+'1')//11
		3.有一边是字符串，就进行字符串拼接 console.log(1+'1')//11
		如果两边有变量，先转成变量存的数据类型，再按照上述执行
	if条件判断
		1.if(判断条件){
			 如果判断条件为真，执行这里的代码
		}
		2.if(判断条件){
			 如果判断条件为真，执行的代码
		}else{
			如果判断条件为假，执行的代码
		}
		3.if(判断条件1){
			如果判断条件1为真，执行的代码
		}else if(判断条件2){
			 如果判断条件2为真，执行的代码
		}else{
			判断条件1和条件2都为假，执行的代码
		}
		布尔值boolean：
			真            假
			true    false
		==:比较两边的值是否相等，相等返回真，不等返回假
		数组
			作用：储存多个数据
			var arr = [];
			1.值与值之间用逗号分隔，注意最后一位后边别加逗号
			2.数组下标数字从0开始,取值arr[0]
			3.length,数据的个数,arr.length,最后一位arr[arr.length-1]
2.获取元素
	 css选择器
		id -- #
		class -- .
		标签名 -- div
	js选择器
		1.id方式
			document.getElementById(''id名称')
		2.class方式
			document.getElementsByClassName('class名')
			元素.getElementsByClassName('class名')
			document和元素限制范围，在范围内，获取指定class名的元素
			获取到的是一个集合，类数组，length获取到元素的个数，数字下标取值，如果只有一个元素，也必须加[0]操作元素
		3.标签名方式
			document.getElementsByTagName('标签名')
			元素.getElementsByTagName('标签名')
			document和元素限制范围，在范围内，获取指定标签名的元素
			获取到的是一个集合，类数组，length获取到元素的个数，数字下标取值，如果只有一个元素，也必须加[0]操作元素
	css选择器
		document.querySelector('css选择器')
		元素.querySelector('css选择器')
		获取到的是一个元素，即使通过标签名或者class，应该获取到一组元素，也只能获取到第一个
		 	
		document.querySelectorAll('css选择器')
		元素.querySelectorAll('css选择器')
		获取到的是一组元素，数字下标取值，length
for循环
	for(初始化变量;判断条件;变量改变){
		 重复执行的代码
	}
	过程：
	1.初始化变量 -- 声明变量i,赋值为0（只执行了一次）
	2.判断条件 -- 判断i是否满足条件，i<6成立，才会执行循环里的代码
	3.逐行执行括号里的代码
	4.变量改变 -- i++，i自增1
	5.判断条件
	6.括号里代码执行
	7.变量改变。。。。。
	注意：
	1.判断条件决定了for是否执行，执行多少次
	2.变量一定要改变，不然就死循环了
	
	取余，取模  %
		1.a < b -> a=2,b=4
			a%b = a
			2%4
		2.a > b
			a%b = a/b余下的数
		3.a = b或a是b的整数倍
			a%b = 0
	Math.floor向下取整,Math.ceil向上取整
	for嵌套for，不要用同一变量i控制，分开用i,j
	例子：for(var i=0;i<10;i++){
			console.log('标记')
			for(var j=0;j<10;j++){
				console.log(i,j)
			}
		}
	this
		关键字
		谁调用这个this,this就指向谁
		1.函数外边调用
			指向window
		2.函数内部调用
			a.直接调用
				调用该事件函数的元素。
			b.函数调用
				指向window
	onmouseover	鼠标输入事件
	onmouseout	鼠标输出事件
非空对象下，可以加自定义属性，索引值
	小例子：for(var i=0;i<btns.length;i++){
		//每个input添加自定义属性index，记录i值，在点的时候就可以通过index知道点的是第几个input，就可以找到对应的第几个div显示了
			btns[i].index = i;
			btns[i].onclick = function(){
			//清除所有Input,div的class
				for(var i=0;i<btns.length;i++){
					btns[i].className = '';
					divs[i].className = '';
				}
				//给当前input和对应的div添加class
				this.className = 'active';
				divs[this.index].className = 'show';
			}
		}
		
		var prev = 0;//记录上一个是第几个
		for(var i=0;i<btns.length;i++){
			btns[i].index = i;
			btns[i].onclick = function(){
				//上一次的input和div的class清除
				btns[prev].className = '';
				divs[prev].className = '';
				//给当前input和对应的div添加class
				this.className = 'active';
				divs[this.index].className = 'show';
				//记录上一次点的是第几个
				prev = this.index;
			}
		}
数据类型
	简单数据类型或者基本数据类型
	String - 字符串
		由0个或者多个字符组成的串
		可以用单引号也可以双引号，但是必须成对出现
	Number - 数字
		整数或者小数
	Boolean - 布尔值
		true - 真
		false - 假
	Null - 空
		只有一个值：null
		当声明一个变量，暂时不知道存什么数据类型，可以先设置为null
	Undefined - 未定义	
		只有一个值：undefined
		当声明变量未赋值，默认值为undefined
	复杂数据类型或复合数据类型
	可以由简单数据类型或者复合数据类型组成
	object - 对象
		var arr = []
		var j = {}
		属性 = 值
		attr = value
		键值对
		当属性名不复合命名规范时，带-，加引号'font-size'
		例子：var j = {
				name:'陈斌',
				age:18,
				duixiang:[],
				'font-size':16,
				fontSize:17
			};
			console.log(j.name);
			console.log(j.age);
			console.log(j.duixiang);
			console.log(j['font-size']);
			console.log(j.fontSize);
	<input type="text" />+<input type="text" />=<input type="text" /><input type="button" value="按钮"/>
	input的value，innerHTML都是字符串//1+1=11
	数据类型转换
		一种数据类型转换成另外一种数据类型
		js可以把任意数据类型转换成下列三种数据类型
		string - 字符串
		number - 数字
		boolean - 布尔值
		同时js提供了基本的转换方法
		String(要转换的数据)
		Number(要转换的数据)
		Boolean(要转换的数据)
	Number()
		如果能转成纯数字就转成数字，如果转不成就是NaN
		NaN:not a number
		NaN的数据类型是数字类型
		字符串
			1.纯数字的字符串，转成数字
			2.前边有0,会忽略
			3.前后有空格,会忽略
			4.空字符串,转成0
			5.不是纯数字还有其他字符（40px）,转成NaN
		布尔值
			 true - 1
			 false - 0
		未定义
			undefined - NaN
		空
			null - 0
		对象
			arr
			1.空数组 - 0
			2.非空数组 - NaN
			{}都是NaN
	typeof 数据
		检测数据类型
		注意：返回首字母是小写
		ECMAScript:string字符串  number数字 boolean布尔值  null空  undefined未定义 object对象
		typeof: string字符串  number数字 boolean布尔值  undefined未定义 object对象 function函数（没有null,null是object）
	字符串转数字
		parseInt()
		整数，忽略第一位非数字往后的字符
		parseFloat()
		小数,忽略非数字部分
		1.纯数字的字符串，转成数字
		2.前边有0,会忽略
		3.前后有空格,会忽略
		4.空字符串,转成NaN
		5.不是纯数字还有其他字符（40px）,转成NaN
	转成字符串类型
		String(要转的数据)
		简易转换法：''+任意数据类型	console.log(''+1)
	转成布尔值
		false:0,'',undefined,null,NaN
		简易版：！取反
		!!数据
		数字
		只有0是false,其他都是true
		字符串
		空字符串是false,有字符就是true
		未定义
		undefined - false
		空
		null - false
	NaN
		NaN与任何数据都不相等，包括也不等于自己
	isNaN()
		先调用Number()，然后再判断是否是NaN
		如果是NaN,返回true
		如果不是NaN,返回false
	显示类型转化
		明确调用某种方法把一种数据类型转换成另外一种数据类型
		Number()
		隐式类型转化
		我们没有明确调用数据类型转换的方法，为了系统运算或者拼接，系统偷偷把类型转换了
	小例子（判断是不是整数）
	inps[1].onclick = function(){
		var val = inps[0].value;
		/*
		 * 100.1  100
		Number() - 100.1 -100
		parseInt() - 100 - 100
		parseFloat() - 100.1 - 100
		 * */
		if(parseInt(val) == parseFloat(val)){
			alert('这是整数')
		}else{
			alert('这不整数')
		}
	}
	小例子（找出数组里最大值）
	var arr = [2,3,6,83,68,23,78,5,1];
	var max = arr[0];
	for(var i=1;i<arr.length;i++){
		if(arr[i]>max){
			max = arr[i];
		}
	}
	console.log(max)
	算术运算符
		+ - * / % ++ --
		n++:先赋值，后运算
		++n:先运算，后赋值
	逻辑运算符
		或与非	|| 
		&& 与，并且
		！非，取反
		||:如果前边为真，就返回前边，如果前边为假，就返回后边的
		&&:如果前边为真，返回后边，如果前边为假，返回前边的
		！：非，取反
		?:三目
	关系运算符
		> < >= <= == != === !==
		==:判断两边值是否相等，相等返回true，不等返回false
		===:先判断两边数据类型是否相同，再判断两边值是否相等，数据类型或者值只要一个不相同，就返回false,都相等返回true
		!=:两边值不等返回true,相等返回false
		!==:数据类型，值，只要有一个不同返回true，都相等返回false
	运算符优先级
		() ++ -- * / + - > < == && || =
	a?b:c 三目，三元运算符
		a判断为true,执行b，a为false执行c
		一元运算符
			+ - ++
		二元运算符
			+ - * /
		三元运算符
			？：
		例子：var a = '1';
			console.log(typeof -a)
			var inps = document.getElementsByTagName('input');
			inps[1].onclick = function(){
				var val = Number(inps[0].value);
				val<10?val='0'+val:val=''+val;
				inps[0].value=val;
			}
	 while循环
		 注意：一定要条件改变，不然就死循环
		var i=0;
		while(i<10){
			执行的代码，
			 i++
		}
		var i=0
		for(;i<10;i++){
			 执行的代码
		}
		例子：var n = 1;
			while(n<10){
				n++;
			}
			console.log(n)
	switch(判断条件){
		case 条件1:
		break;
		case 条件2:
		break;
		default:
		break;
	}
	if(n==1){
		alert('n=1')
	}else if(n==2){
		alert('n=2')
	}else{
		alert('都不成立')
	}
	注意：break不写，穿透
	例子：var n=1;
		switch (n){
			case 1:
			alert('n=1')
			break;
			case 2:
			alert('n=2')
			break;
			default:
			alert('都不成立')
			break;
		}
	break
	终止循环
	for循环：break后边的代码不执行，同时跳出循环
	continue
	跳过
	for循环：continue后边的本次循环的代码不执行
	例子:for(var i=0;i<10;i++){
		if(i==5){
			//break;
			continue;
		}
		console.log(i)
		}
		console.log('标记')
	for in
		循环，遍历，迭代
		for(var k in j){}
	函数 function
		作用：复用代码，声明一个函数，把要复用的代码放到函数里，在需要用的时候调用这个函数，里边的代码就会逐行执行
		函数声明式
		function 函数名(){}
		可以先声明再调用，也可以先调用，再声明
		函数表达式
			var fn = function(){}
		必须先声明，后调用
	函数参数
		我们可以给函数里传入一些数据，让函数的执行或者返回结果有一些变化，函数的可用性和扩展性更高
		参数
			由0个或者多个组成，中间用逗号分隔
		形参
		 	1.在函数声明时，定义形参
		 	2.形参只能在函数内部
		 	3.形参相当于在函数内部使用的变量
		 	4.在函数调用时，传入实参，给形参一一对应赋值
		 	5.没有赋值时，默认值是undefined
		 实参
		 	1.在函数调用时候传入
		 	2.一一对应赋值给形参
	arguments
		参数集合，类数组，length,数字下标取值，从0开始
		一般在不定参数时使用,不写形参，只能在函数内部使用
		传入实参时，一一对应赋值给形参，同时会把数据存入arguments里
	例子：var n = 0;
		function fn(){
			for(var i=0;i<arguments.length;i++){
				n+=arguments[i];
			}
			console.log(n)
		}
		fn(1,2,3,4,5,6,7,8,9,11,2,3,5,6,7,8,4,7,89,90);	
	return 函数返回值
		让函数执行的结果有一定的变化，默认值是undefined,可以返回任意数据类型，只能在函数内部使用
		fn()就等于return后边的数据
		作用：
			1.函数执行完返回我们指定的数据
			2.终止函数后边的代码执行
	例子：var uls = document.getElementsByTagName('ul');
		for(var i=0;i<uls.length;i++){
			if(i==0){
				fn(i,'red');
			}else{
				fn(i,'blue');
			}	
		}
		function fn(n,color){
		var lis = uls[n].getElementsByTagName('li');
		for(var i=0;i<lis.length;i++){
			lis[i].onclick = function(){
				for(var i=0;i<lis.length;i++){
					lis[i].style.background = '';
				}
				this.style.background = color;
				}
			}
		}
作用域
	变量和函数起作用的区域，可访问的区域
	全局作用域
		没在函数里声明的变量和函数，就是全局的，也就是全局可用
	函数作用域（局部作用域）
		在函数里声明的变量和函数，只能在该函数里（包括子函数里）访问，函数外不能直接访问
	函数可以套函数声明，一个函数声明在另一个函数内
全局作用域
	在全局声明的变量或者函数，全局可用
函数作用域
	在函数内声明的变量或函数，只能在该函数内(子函数内)使用，不能在函数外直接使用
	例子：function fn(){
			var a = 1;
			function fn1(){
				console.log('函数作用域');
			}
			fn1();//函数内部可以访问
			return fn1;
		}
		console.log(fn()())//函数作用域,函数作用域,undefined
	作用域链
		变量和函数的查找规则
		函数内>形参>全局
	例子：var a=1;
		function fn(a){
			var a=3;
			console.log(a);
		}
		fn(2);	
	window
		js内置对象
		全局var声明变量或者函数一个变量，同时就会在window上创建一个属性名为变量名，值就为变量值	
	一般我们用var声明变量，也可以不用
		首次给一个未定义的变量赋值,系统会自动创建这个变量，但是是全局变量
		但是不推荐，声明变量一定要用var，不然会造成全局污染
	delete 操作符
		作用：删除对象下属性
		用var声明的变量，不能用delete删除
		返回值：
			能删除，返回true
			不能删除，返回false
	例子：a = 1;
		var b=2;
		delete a;
		delete b;
		function fn(){
			var c=3;
			console.log(delete c)
		}
		fn();
		console.dir(window)
	预解析
		js代码在执行之前，会先把var声明的变量和函数，提到当前域的最前边，然后再逐行执行代码
		var 
			a
		函数
			function fn(){}
		执行
			a=1;
			a=2;
			fn=1;
	全局
		var a
		 	a=1
		fn
	fn函数
		var a
		a=2
		a=3
	例子：console.log(a,b,fn)//undefined undefined function fn(){}
		var a=1;
		fn();
		function fn(){}
		var b = 3;
		a = 2;
		fn = 1;
		console.log(a,b,fn)//2 3 1
闭包
	函数套函数声明就是闭包，内部生成闭包空间
	内部函数可以访问外部函数的数据，外部函数不能访问内部函数的数据
	例子：function a(){
			var b = 1;
			function c(){
				b++;
				console.log(b)
			}
			return c;
		}
		var f = a();
		f();//2
		f();//3
函数自执行
		 匿名函数声明后直接执行，就不会报错
	( function(){} )()推荐
	例子：(function (){
			var a = 1;
			a++;
			console.log(a)
		})()
		var lis = document.getElementsByTagName('li');
		for(var i=0;i<lis.length;i++){
			lis[i].index = i;
			lis[i].onclick = function(){					
				console.log(this.index)
			}
			(function(n){
				lis[n].onclick = function(){
					console.log(n)
				}
			})(i)
			~function(n){
				lis[n].onclick = function(){
					console.log(n)
				}
			}(i)
		}
	getComputedStyle(元素)
			 得到的是一个对象
			 得到某个样式，带单位的字符串值,页面渲染后(计算后)的值
			 	getComputedStyle(元素).width
			 注意：复合样式返回的是所有的值	
			 标准浏览器
			 	getComputedStyle(元素)	alert(getComputedStyle(div).width)
			 非标准
			 	元素.currentStyle	alert(div.currentStyle.width)
	获取元素样式值函数
			 obj：元素，object
			 attr：样式,string
	例子：获取元素样式函数封装
		function getStyle(obj,attr){
		//obj.currentStyle在非标准可以获取到对象，布尔值是true，在标准下是undefined，布尔值是false,所以用这个做判断条件区分标准和非标准浏览器
			if(obj.currentStyle){
				//非标准
				return obj.currentStyle[attr];
			}else{
				//标准
				return getComputedStyle(obj)[attr];
			}
		}
		console.log(getStyle(div,'height'))
	例子：获取元素函数封装
		function getById(name){
			return document.getElementById(name);
		}
		function getByClass(name,obj){
			var obj = obj || document;
			return obj.getElementsByClassName(name);
		}
		var div = getById('div');
		var list = getById('list');
		var lis = getByClass('a',list);
		console.log(lis)
	例子：数字炸弹
		var inps = document.getElementsByTagName('input');
		var a;//随机的数字
		var max = 100;
		var min = 0;
		var onOff = false;
		//确认
		inps[1].onclick = function(){
			if(onOff){
				var val = Number(inps[0].value);
				if(val > a){
					max = val;
				}
				if(val < a){
					min = val;
				}
				if(val == a){
					alert('炸了');
				}else{
					alert(min + '~' + max);
				}
			}	
			}
		//开始
		inps[2].onclick = function(){
			onOff = true;
			a = Math.round(Math.random()*100);
		}
		//重置
		inps[3].onclick = function(){
			onOff = false;
			max = 100;
			min = 0;
		}
定时器
	重复执行定时器
		setInterval()
	延时执行定时器
		setTimeout()
	重复执行定时器
	设置定时器
		setInterval(函数，间隔时间)
		参数
			间隔时间
			1秒=1000毫秒
			毫秒，不带单位
		返回值
			数字类型 定时器的编号或者叫Id,从1开始
	关闭定时器	
		clearInterval()
	例子：自动图片切换
	var img = document.getElementById('img');
	var prev = document.getElementById('prev');
	var next = document.getElementById('next');
	var n = 0 ;
	var arr = ['img/0.jpg','img/1.jpg','img/2.jpg','img/3.jpg','img/4.jpg'];
	var box = document.getElementById('box');
	var timer = null;
	var lis = document.getElementsByTagName('li');
	function tab(){
		if(n > arr.length-1){
			n = 0;
		}
		if(n < 0){
			n = arr.length-1;
		}
		for(var i=0;i<lis.length;i++){
			lis[i].className = '';
		}
		lis[n].className = 'active';
		img.src = arr[n];
	}
	next.onclick = function(){
		n++;
		tab();
	}
	prev.onclick = function(){
		n--;
		tab();
	}
	for(var i=0;i<lis.length;i++){
		lis[i].index = i;
		lis[i].onclick = function(){
			n = this.index;
			tab();
		}
	}
	timer = setInterval(function(){
		n++;
		tab();
	},1000);
	box.onmouseover = function(){
		clearInterval(timer);
	}
	box.onmouseout = function(){
		timer = setInterval(function(){
			n++;
			tab();
		},1000);
		console.log(timer)
	}
	例子：运动
	btn.onclick = function(){
			//count目标点位置
			var c = 400;
			//speed速度
			var s = 3;
			timer = setInterval(function(){
				//begin起始位置
				var b = parseFloat(getComputedStyle(box).left);
				var v = b+s;
				//396+3 = 399
				//399+3 = 402
				if(v >= c){
					v = c;
					clearInterval(timer)
				}
				box.style.left = v+'px';
				console.log(box.style.left)
			},20)
	}
时间对象，时间戳
		new Date()
		获取到的是本地时间，时间对象下有一些方法，可以让我们获取或者设置时间
		1970年1月1日00:00:00格林尼治时间
		注意：月从0开始，0是一月，11是十二月
		设置时间对象3种格式
			1.数字，用逗号分隔（年,月,日,时,分,秒）
			2.字符串,月份英文或缩写,首字母大小写都行，用逗号或者空格分隔(月 日 年 时:分:秒)
			3.对象,时间对象
	获取时间
		getFullYear() -- 年
		getMonth()    -- 月（从0开始，0就是一月）
		getDate()     -- 日
		getDay()      -- 星期几（星期一就是1,星期日是0）
		getHours()    -- 小时 
		getMinutes()  -- 分
		getSeconds()  -- 秒
		getMilliseconds()--毫秒
		getTime()     --时间，当前时间距离1970年1月1日00:00:00的毫秒时间差
		var date = new Date();
		console.log(date.getFullYear())
		console.log(date.getMonth())
		console.log(date.getDay())
		console.log(date.getDate())
		console.log(date.getHours())
		console.log(date.getMinutes())
		console.log(date.getSeconds())
		console.log(date.getMilliseconds())
		console.log(date.getTime())
	设置时间
		setFullYear() -- 年
		setMonth()    -- 月（从0开始，0就是一月）
		setDate()     -- 日
		setHours()    -- 小时 
		setMinutes()  -- 分
		setSeconds()  -- 秒
		setMilliseconds()--毫秒
		setTime()     --时间，当前时间距离1970年1月1日00:00:00的毫秒时间差
		var date = new Date();
		date.setFullYear(2015);
		date.setMonth(0);
		date.setDate(1);
		date.setHours(10);
		date.setMinutes(50);
		date.setSeconds(10);
		date.setTime()
	例子：时钟	var imgs = document.getElementsByTagName('img');
			function show(){
				var date = new Date();
			//10:52:02
			var h = date.getHours();
			var m = date.getMinutes();
			var s = date.getSeconds();
			//获取时间拼成我们想要的格式
			var str = two(h)+':'+two(m)+':'+two(s);
			//用我们拼好的时间字符串调整对应图片的数字，时钟就动起来了
			for(var i=0;i<imgs.length;i++){
				//第2和5位是:，所以跳过
				if(i == 2 || i == 5){
					continue;
				}
				imgs[i].src = 'img/'+str.charAt(i)+'.jpg';
			}
			//补0
			function two(n){
				return n<10?'0'+n:''+n;
			}
			console.log(str);
			}
			//初始化
			show();
			//开启定时器，每1秒执行一次
			setInterval(show,1000)
	例子：时间格式化var arr = [2016,10,1,10,1,10];
			//2016年10月1日10时1分10秒
			function fn(arr,n){
				var s = '';
				var n = n || 0;
				//var str = '年月日时分秒';
				var aStr = ['年月日时分秒','-- ::','// ::'];
				for(var i=0;i<arr.length;i++){
					s += arr[i]+aStr[n].charAt(i);
				}
				return s;
			}
			console.log(fn(arr))//2016年10月1日10时1分10秒
	例子：无缝轮播图var arr = ['img/img14.jpg', 'img/img22.jpg', 'img/img24.jpg' ,'img/img25.jpg','img/img32.jpg','img/img33.jpg','img/img36.jpg','img/img42.jpg','img/img43.jpg'];
			var box = document.getElementById('box');
			var as = box.getElementsByTagName('a');
			var ul = box.getElementsByTagName('ul')[0];
			var imgs = box.getElementsByTagName('img');
			var n = 0;
			var onOff = true;
			var timer = null;
			//下一张
			/*	n=0
 				img1,img2
 			运动前
 				img1 = 0
	 			img2 = 0
	 		点击瞬间
	 			img1 = 0
	 			img2 = 1
 			运动中
 				img1 = 0
 				img2 = 1
 			运动后
			 * 	img1 = 1
 				img2 = 1
 			瞬间回到初始位置
 			这个时候看到的是img1
 		
			 * */
			//左边下一张
			as[0].onclick = function(){
				if(onOff){
					onOff = !onOff;
					n++;
					if(n > arr.length-1){
						n = 0;
					}
					imgs[1].src = arr[n];
					move(ul,'left',-640,2000,function(){
						imgs[0].src = arr[n];
						ul.style.left = '';
						onOff = !onOff;
					})
				}
			}
			as[1].onclick = function(){
				if(onOff){
					onOff = !onOff;
					imgs[1].src = arr[n];
					ul.style.left = '-640px';
					n--;
					if(n < 0){
						n = arr.length-1;
					}
					imgs[0].src = arr[n];
					move(ul,'left',0,2000,function(){
						onOff = !onOff;
					})
				}
			}
			timer = setInterval(as[0].onclick,2000);
			box.onmouseover = function(){
				clearInterval(timer);
			}
			box.onmouseout = function(){
				timer = setInterval(as[0].onclick,2000);
			}
赋值
		var a = 1;
		var b = a;
		b = 2;
		console.log(a,b)//1 2
赋址
		var j = {
			a:1,
			b:2
		}
		var j1 = j;
		j.a = 3;
		console.log(j,j1)//3,2 3,2
逗号操作符，返回最后一个值
		for(var i=0,j=0;j<6,i<10;i++,j++){
			//console.log(i,j)
		}
		var n = (1,2,3);
		console.log(n)//3
	例子：翻页时钟/*
	 		1.获取旧时间，拼成字符串
	 		2.Img对应字符串初始化
	 		3.开定时器，获取新时间
	 		4.对比新旧时间的每一位不一样，哪一位Li翻页
	 		5.旧时间 = 新时间
	 		old = 14:00:00
	 		new = 14:00:01
	 		old = new
	 		new = 14:00:02
	 		old = 14:00:01
			 * */
	var lis = document.getElementsByTagName('li');
	var img2 = lis[2].getElementsByTagName('img')[0];
	var img5 = lis[5].getElementsByTagName('img')[0];
	//初始化时间，记录旧时间
	var oldTime = getTime();
	//初始化时间
	for(var i=0;i<lis.length;i++){
		fn(i);
	}
	function fn(n){
		var img = lis[n].getElementsByTagName('img')[0];
		if(n == 2 || n == 5){
			img.src = 'img/c.jpg';
		}else{
			img.src = 'img/'+oldTime.charAt(n)+'.jpg';
		}
	}
	setInterval(function(){
		//点闪烁
		img2.src = img5.src = 'img/c.jpg';
		setTimeout(function(){
			img2.src = img5.src = 'img/b.jpg';
		},500)
		//获取新时间
		var newTime = getTime();
		//对于新旧时间，哪一位不一样，哪一位执行翻页
		for(var i=0;i<newTime.length;i++){
			if(oldTime.charAt(i) != newTime.charAt(i)){
				//翻页效果需要哪一位i,新数字是什么newTime.charAt(i)
				tab(i,newTime.charAt(i))
			}
		}
		//记录旧时间
		oldTime = newTime;
	},1000)
	//获取时间字符串
	function getTime(){
		var date = new Date();
		var h = date.getHours();
		var m = date.getMinutes();
		var s = date.getSeconds();
		var str = '';
		str = toDouble(h) + ':' + toDouble(m) + ':' + toDouble(s); 
		return str;
	}
	//补0
	function toDouble(n){
		return n<10?'0'+n:''+n;
	}
	//翻页效果
	function tab(n,s){
		var oLi = lis[n];
		var str = s;
		var imgs = oLi.getElementsByTagName('img');
		imgs[1].src = 'img/'+s+'.jpg';
		move(oLi,'top',-70,800,function(){
			imgs[0].src = 'img/'+s+'.jpg';
			oLi.style.cssText = '';
		})
	}
字符串
	由0个或多个字符组成的串
	string.length
	返回该字符串有多少个字符
	只能读取，不能设置
	string.charAt(index)，String
	作用：查找字符串某一位置是什么字符
	参数：
		index:查找第几位是什么字符串，第一位是0
	注意：
		1.只能获取，不能设置
		2.没有这一位，返回空字符串
	string.charCodeAt(index),Number
	作用：返回字符串某一位字符串的unicode码
	参数：
		index：第几位，从0开始
		[a-z]:97-122
		[A-Z]:65-90
		[0-9]:48-57
	例子：第几位不是数字	var str = "1285hf25678m2367";
				for(var i=0;i<str.length;i++){
					var s = str.charCodeAt(i);
					if(s<48 || s>57){
						console.log('第'+i+'位不是数字')
					}
				}
	string.indexOf(searchValue,[index]),Number
			作用：从字符串第一位开始查找指定的字符第一次出现的位置(从左往右)
			参数：
			 	searchValue：要查找的字符，string
			 	[index]:从第几位开始找，默认值为0
			 注意：
			 	1.没找到指定字符，返回-1
			 	2.不传参数，返回-1
	string.lastIndexOf(searchValue,[index]),Number
			作用：从字符串最后一位开始查找指定的字符第一次出现的位置(从右往左)
			参数：
			 	searchValue：要查找的字符，string
			 	[index]:从第几位开始找，默认值为最后一位
			 注意：
			 	1.没找到指定字符，返回-1
			 	2.不传参数，返回-1
	string.split(separate),Array
			 作用：把字符串用指定分隔符分隔，放到数组里返回
			 参数：
			 	separate:分隔符
			 注意：
			 	1.不传参数，把整个字符串放到数组里返回
			 	2.分隔符是空字符串''，字符串的每一个字符都是一个结果放到数组里返回
			 	3.用字符串里没有的字符分隔，把整个字符串放到数组里返回
	Array.join(separate),String
			 作用：把数组里的值用分隔符连接成字符串返回
			 参数：
			 	separate：连接符
			 注意：
			 	1.不传参数，默认连接符是逗号
	string.toLowerCase(),String
			 作用：把字符串里大写变成小写
	string.toUpperCase(),String
			 作用：把字符串里小写变成大写
	confirm('提示文字')
			 返回值：
			 	点确定：true
			 	点取消：false
	prompt('提示文字')
			 返回值：
			 	点确定：输入的字符串
			 	点取消：null
	判断	var n = 0;
		console.log(2<n<5)
		//2<0,false<5 ,0<5 = true
	string.slice(begin,[end]),string
		作用：
			 截取字符串中某一段字符片段
		参数：
			 begin:开始位置
			 [end]:结束位置,默认是最后一位
		注意：var str = 'miaov';
			1.不传参数，返回整个字符串	console.log(str.slice())//miaov	console.log(str.slice(1))//iaov
			2.从开始位置截取到结束位置，不包括结束位置的字符	console.log(str.slice(1,3))//ia
			3.结束位置-开始位置 = 截取的字符个数，从开始位置截取几个字符	console.log(str.slice(1,10))//iaov	console.log(str.slice(1,3))//ia
			4.截取不到，返回空字符串	console.log(str.slice(3,1))//空字符串
			5.-1是最后一位	console.log(str.slice(-1))//v
	string.substring(begin,[end]),string
		作用：
			 截取字符串中某一段字符片段
		参数：
			 begin:开始位置
			 [end]:结束位置,默认是最后一位
		注意：var str = 'miaov';
			 1.不传参数，返回整个字符串	console.log(str.substring())//miaov	console.log(str.substring(1))//iaov
			 2.从开始位置截取到结束位置，不包括结束位置的字符	console.log(str.substring(1,3))//ia	console.log(str.substring(1,10))//iaov
			 3.结束位置-开始位置 = 截取的字符个数，从开始位置截取几个字符	console.log(str.substring(1,3))//ia
			 4.截取不到，返回空字符串	console.log(str.substring(10))//空字符串
			 5.与slice区别
			  	a.大小，会自动转成小大	console.log(str.substring(3,1))//ia
			  	b.负数	console.log(str.substring(-1))//miaov
	string.substr(begin,[length]),string
		作用
			 截取字符串中某一段字符片段
		参数：
			 begin:开始位置
			 [length]：截取长度
		注意：var str = 'miaov';
			 1.不传参数，返回整个字符串	console.log(str.substr())//miaov	console.log(str.substr(1))//iaov
			 2.从开始位置截取到结束位置，包括结束位置的字符	console.log(str.substr(1,3))//iao
			 3.结束位置-开始位置 = 截取的字符个数，从开始位置截取几个字符	console.log(str.substr(1,3))//iao
			 4.截取不到，返回空字符串	console.log(str.substr(10))//空字符串
			 5.-1是最后一位	console.log(str.substr(-1))//v
	string.trim(),string
		作用:
			 去除字符串前后空格
数组
	arr = []
		由0个或者多个数据组成的集合
		1.有序性，从0开始
		2.访问和操作数据通过数字下标arr[0]
		3.length
	array.push(val1,val2,...)，Number
		作用：
			 向数组的尾部添加数据
		参数：
			 val1,val2：向数组添加的数据，可以是1个也可以是多个，用逗号分隔
		返回值：
			 新数组的长度
	array.pop()，mixed
		作用：
			 删除数组最后一位数据
		返回值：
			 删除的那个数据
	array.unshift(val1,val2,...)，Number
		作用：
			 向数组的头部添加数据
		参数：
			 val1,val2:向数组添加的数据，可以是1个也可以是多个，用逗号分隔
		返回值：
			 新数组的长度
	array.shift()，mixed
		作用：
			 删除数组第一位数据
		返回值：
			 删除的那个数据
	array.reverse(),Array
		作用：
			 翻转数组
		返回值：
			 翻转后的数组
	array.concat(val1,val2,...),Array
		作用：
			 连接原数组和新数据
		参数：
			 val1,val2:向数组连接的数据，可以是1个也可以是多个，用逗号分隔
		返回值:
			 新数组，注意原数组不变
	array.sort(funtion(){})
		作用：
			 根据一定规则给数组排序
		参数：
			 函数：
			 	一定要写形参和返回值
			 	a-b:从小到大
			 	b-a:从大到小
			 	Math.random()-0.5:随机排序
			 注意：
			 	1.不传参数，根据ASCII码的大小排序
			 	2.排序规则
			 	根据返回值大于0，等于0，小于0决定是否交换2个值的位置
	例子：var arr = [2,8,6,4,9,20,16];
		var arr1 = [{id:1,color:'red'},{id:2,color:'blue'},{id:3,color:'green'}]
		arr1.sort(function(a,b){
			return a.id-b.id;
		})
		console.log(arr1)
	array.forEach(function(){})
		作用：
			 循环、遍历数组
		参数：
			 第一个参数：数组里每一个值
			 第二个参数：数组里的位置
			 第三个参数：整个数组
	例子：var arr=[];
		for(var i=0;i<inps.length;i++){
			arr.push(inps[i])
		}
		arr.forEach(function(a,b,c){
			//console.log(a,b,c)
			a.onclick = function(){
				for(var i=0;i<c.length;i++){
					c[i].style.background = '';
					lis[i].style.background = '';
				}
				this.style.background = 'red';
				lis[b].style.background = 'red';
			}
		})
	array.every(function(){})
		作用：
			 遍历数组，如果每一位值都满足条件，返回true,有一个不满足，就返回false
		参数：
			 第一个参数：数组里每一个值
			 第二个参数：数组里的位置
			 第三个参数：整个数组
		注意：
			 一定要写return,形参
	例子：var arr = [1,2,3,4];
		console.log(arr.every(function(a,b,c){
			console.log(a,b,c)
			return a>0
		}))
	array.filter(function(){})
		作用:
			遍历数组，满足条件的值放新数组里返回
	例子：var arr = [1,2,3,4];
		console.log(arr.filter(function(a){
			return a>2;
		}))
		console.log(arr)
	array.map(function(){})
		作用：
			 遍历数组，把每个值判断的结果放到新数组里返回
	例子：var arr = [1,2,3,4];
		console.log(arr.map(function(a){
			return a>2;
		}))
	array.some(function(){})
		作用：
			遍历数组，只要有一个值满足判断条件，就返回true,都不满足，返回false
	例子：var arr = [1,2,3,4];
		console.log(arr.some(function(a){
			return a>5;
		}))
	array.slice(begin,[end]),Array
		作用：截取数组指定位置的数据片段，放到新数组返回，原数组不变
		参数：
			 begin:开始位置
			 [end]:结束位置,默认是最后一位
		注意：
			 1.不传参数，把数组内每个值放到新数组内返回
			 2.从开始位置，截取到结束位置，不包括结束位置
			 3.从开始位置，结束位置-开始位置=截取个数
			 4.-1是最后一位
			 5.截取不到，返回空数组
	array.splice(begin,[length],val1,val2,...)
		作用：
			 删除，添加，替换
		参数：
			 begin:开始位置
			 [length]:长度
			 val1,val2:要替换或者添加的数据
		删除：
			 begin:从哪位开始删
			 [length]:删除几位
		添加：
			 begin：开始位置
			 [length]:0
			 val1,val2:要添加的数据，可以是1个，也可以是多个，用逗号分隔
		替换：
			 begin：开始位置
			 [length]:要替换几个
			 val1,val2:要替换的数据，可以是1个，也可以是多个，用逗号分隔
	例子：var arr = [1,2,3,4];
		删除
		arr.splice(1,2);
		console.log(arr)//[1, 4]
		添加
		arr.splice(1,0,9,8,7);
		console.log(arr)//[1, 9, 8, 7, 2, 3, 4]
		替换
		arr.splice(1,2,9,8,7);
		console.log(arr)//[1, 9, 8, 7, 4]
	数组去重	例子：
	var arr = [1,2,1,1,1];
	for(var i=0;i<arr.length;i++){
		for(var j=i+1;j<arr.length;j++){
			if(arr[i] == arr[j]){
				arr.splice(j,1);
				j--;
			}
		}
	}
	console.log(arr)
冒泡算法：
	需求：
		1.封函数
		2.传入arr，返回1-8从小到大排序好的数组
		3.冒泡算法
		4.2个值进行比较，如果前边的比后边的大，就交换位置，第一次循环完，得到最大值，在最后一位
		5.再进行第二次比较。。。
		6.返回排序好的数组
	var arr1 = [1,2,5,3,8,7,6,4];
	var n = 0;
	function bubbleSort(arr){
		//比较多少次
		for(var i=0;i<arr.length;i++){
			//比较每个值，交换位置
			//console.log('a')
			for(var j=0;j<arr.length;j++){
				var a = arr[j];
				var b = arr[j+1];
				//console.log(a,b)
				if(arr[j]>arr[j+1]){
					arr[j] = b;
					arr[j+1] = a; 
				}
				n++;
				//console.log(arr)
			}
		}
		return arr;
	}
	console.log(bubbleSort(arr1));
	console.log(n)
冒泡算法2：
	var arr1 = [1,2,5,3,8,7,6,4];
	var n = 0;
	function bubbleSort(arr){
		//比较多少次
		for(var i=0;i<arr.length-1;i++){
			var onOff = true;
			//比较每个值，交换位置
			console.log('a')
			for(var j=0;j<arr.length-i-1;j++){
				var a = arr[j];
				var b = arr[j+1];
				//console.log(a,b)
				if(arr[j]>arr[j+1]){
					arr[j] = b;
					arr[j+1] = a; 
					onOff = false;
				}
				n++;	
			}
			console.log(onOff)
			if(onOff){
				break;
			}	
		}
		return arr;
	}	
	console.log(bubbleSort(arr1));
	console.log(n)
递归：函数自己调用自己
	1.有条件的调用
	var a = 0;
	function fn(){
		a++;
		if(a<10){
			fn();
		}
	}
	fn();
	console.log(a)
	2.有终止条件
	function fn(n){
		if(n==1){
			return 1;
		}
		return fn(n-1)+n;
	}
	console.log(fn(5))
	1+2+3+4+5=15
	fn(5)
	fn(4)+5
	fn(3)+4
	fn(2)+3
	fn(1)+2
	1
快排算法:
	1.切出数组第一位值作为比较值，存为c
	2.准备2个数组，left和right
	3.循环数组的第一位值与c做对比，比c小切出来放入left,比c大切出来放入right
	4.如果arr.length=0证明数组内的值都对比完了，0的布尔值是false，终止循环
	5.left c right，按顺序用concat连接起来返回
	6.如果left,right还需要拆分，递归调用自身函数
	7.所以写成quickSort(left).concat(c,quickSort(right))
	left[]	arr1[0]=1  right[2,5,3,8,7,6,4]
	left[]   right[0]=2   right[5,3,8,7,6,4]
	left[3,4]	 right[0]=5   right[8,7,6]
	left[] left[0]=3  right[4]
	left[7,6]	right[0]=8  right[]
	left[6] left[0]=7 right[]
	例子：var arr1 = [1,2,5,3,8,7,6,4];
		function quickSort(arr){
			//终止条件arr.length<=1，数组为空数组或者只有1个值
			if(arr.length<=1){
				return arr;
			}
			//切出数组第一位值作为比较值
			var c = arr.shift();
			//准备2个数组left,right
			var left = [];
			var right = [];
			//数组length为0，证明都比较完了，跳出循环，否则就会循环比较
			while(arr.length){
				//数组第一位值与c比较
				if(arr[0]>c){
					//比c大，切出来放入right
					right.push(arr.shift())
				}else{
					//比c小，切出来放入left
					left.push(arr.shift())
				}
			}
			console.log(left,c,right)
			//left,c,right按顺序连接
			//left,right还需要切，递归调用自身函数
			return quickSort(left).concat(c,quickSort(right));
		}
		console.log(quickSort(arr1))
JSON
	javascript object notation
	是一种轻量级数据交换格式,类型是字符串
	长得像对象的字符串'{}','[]'
		不支持undefined
		5,"",null,true,'{}','[]'
		//对象格式
		{
			name:'小红'，
			age:18
		}
		//JSON格式，属性名必须加双引号，数据类型是字符串也要双引号
                '{"name":"小红","age":18}'
	JSON.parse(string)
		作用：把JSON字符串转成对象
		var j = '{"name":"小红","age":18}';
		console.log(JSON.parse(j).name)
	JSON.stringify(object)
		作用：把对象转成JSON字符串
		var j={
			name:'小红',
			age:18
		}
		console.log(JSON.stringify(j))
js三部分组成
	ECMAScript
			javascript核心标准，定义并实现了JS的基本语法，数据类型，类型转换，内置对象，方法的基本标准
	DOM（文档对象模型）
			document object model
			根据ECMAScript扩展出来操作页面的标准
			提供创建、删除、修改、插入等操作页面的方法和标准，赋予我们操作页面的权利
	BOM（浏览器对象模型）
			browser object model
			提供浏览器相关的方法和标准，比如打开/关闭窗口，地址栏
	DOM
		document本质是字符串,页面在解析时，会调用js解析器，把标签解析成对象，对象下有很多方法，操作页面元素就很方便
		js在解析时，会解析成DOM树（对象），DOM树由DOM节点组成，我们操作页面操作的就是这些节点
		节点类型有12种，不同的节点类型，操作的方法也不一样
		比如：标签就是元素节点，文字就是文本节点，注释就是注释节点
	节点类型
		ELEMENT_NODE 	                1
		ATTRIBUTE_NODE 	                2
		TEXT_NODE 	                3
		DATA_SECTION_NODE 	        4
		ENTITY_REFERENCE_NODE 	        5
		ENTITY_NODE 	                6
		PROCESSING_INSTRUCTION_NODE 	7
		COMMENT_NODE 	                8
		DOCUMENT_NODE 	                9
		DOCUMENT_TYPE_NODE 	        10
		DOCUMENT_FRAGMENT_NODE 	        11
		NOTATION_NODE 	                12
	例子：<div id="div" class="a">
			<span></span>
			<!--注释-->
			文字
		</div>
	 node:节点
	 E：元素节点
		node.nodeType
		作用：查看节点类型，返回Number
		常用的节点类型
			 1 - 元素节点
			 2 - 属性节点
			 3 - 文本节点
			 8 - 注释节点
			 9 - document节点
	var div = document.getElementById('div');
	console.log(div.nodeType)//1
	//E.attributes获取到属性的集合
	var attrs = div.attributes;
	console.log(attrs[1].nodeType);//2
	//E.childNodes获取到所以第一级子节点
	var child = div.childNodes;
	console.log(child[3].nodeType)//8
	//console.log(child[0].nodeType)
	console.log(document.nodeType)//9
		node.nodeName
		作用：查看节点名称,返回String
	var div = document.getElementById('div');
	//1.元素类型节点，大写标签名
	console.log(div.nodeName)//DIV
	//2.属性类型节点，小写属性名
	var attrs = div.attributes;
	console.log(attrs[0].nodeName)//id
	//3.文本类型节点，#text
	var child = div.childNodes;
	console.log(child)
	console.log(child[0].nodeName)//#text
	//8.注释类型节点，#comment
	console.log(child[3].nodeName)//#comment
	//9.document节点,#document
	console.log(document.nodeName)//#document
	E.childNodes
		作用：获取所有第一级子节点，是个集合，记得加下标
		标准下：
			childNodes所有的第一级子节点
		非标准下：
			childNodes所有第一级元素节点
	E.children
		作用：获取所有第一级元素节点,是个集合，记得加下标
		不是标准方法
	var div = document.getElementById('div');
	//var child = div.childNodes;
	var child = div.children;
	//console.log(child)
	//alert(child[0].nodeName)
	alert(child[0].nodeName)
	例子：var lis = document.getElementsByTagName('li');
		for(var i=0;i<lis.length;i++){
			lis[i].onmouseover = function(){
				var child = this.children[0];
				//console.log(child)
				if(child){
					child.style.display = 'block';
				}
			}
			lis[i].onmouseout = function(){
				var child = this.children[0];
				//console.log(child)
				if(child){
					child.style.display = '';
				}
			}
		}
	E.parentNode
		作用：获取该元素节点的父级元素节点
		只能获取，不能设置
	例子：var spans = document.getElementsByTagName('span');
		for(var i=0;i<spans.length;i++){
			spans[i].onclick = function(){
				this.parentNode.style.background = 'red';
			}
		}
	E.previousElementSibling
		作用：获取上一个兄弟元素节点
	E.nextElementSibling
		作用：获取下一个兄弟元素节点
	E.firstElementChild
		作用：获取E元素节点下第一个元素子节点
	E.lastElementChild
		作用：获取E元素节点下最后一个元素子节点
	E.offsetParent
		 作用：获取E的定位父级元素,属性值不为static
		 注意：
		 	1.没有定位父级，找到body
		 	2.body是null
	E.offsetLeft
		 作用：获取E左边框外，到E的定位父级的左边框内的距离，不带单位
	E.offsetTop
		 作用：获取E上边框外，到E的定位父级的上边框内的距离，不带单位
		 没有定位父级，自身也不是定位元素，获取到的是到html的距离，注意：body自带margin：8px，需要清除默认样式
	firefox:
		 问题：定位父级同时有border和overflow,offsetLeft会重新计算
		 解决：
		 	1.不让border和overflow在定位父级上同时存在
	获取元素宽/高
		1.style
			 只能获取行间样式，带单位
		2.getComputedStyle()
			 页面渲染后的、计算后的样式值，带单位
		3.clientWidth/clientHeight
			 自身宽/高+padding，不带单位
		4.offsetWidth/offsetHeight
			 自身宽/高+padding+border，不带单位
		注意：
			 内嵌元素clientWidth是0
	页面可视区宽/高
		document.documentElement.clientWidth
		document.documentElement.clientHeight
	E.getBoundingClientRect()
		 对象，top bottom left right width height,不带单位
		 注意：bottom
		 下边框外到可视区上边的距离
		 right
		 右边框外到可视区左边的距离	
		 width/height
		 自身宽/高+padding+border
	属性操作方法
		1.通过.的方式
		2.通过[]的方式
			前2种可以操作或访问固有属性，js添加自定义属性
		3.E.getAttribute('属性名')
			获取行间的固有属性和行间自定义属性
			<div id="div1" class="a" b="2"></div>
			var div1 = document.getElementById('div1');
			div1.index = 1;
			//console.log(div1.b)//undefined
			console.log(div1.getAttribute('b'))
			console.log(div1.getAttribute('id'))
			console.log(div1.getAttribute('index'))//null
		E.setAttribute('属性名'，'属性值')
		 	作用：设置行间属性名和值
	E.removeAttribute('属性名')
		 作用：删除行间属性名及属性值
document.createElement('标签名')
	作用：创建元素
		createElement是document下的方法，所以必须这么写
		只是创建了元素，但是页面上还没有这个元素，必须要放到页面中，这样页面上才有这个元素
父级节点.appendChild(要插入的节点)
	作用：向父级节点最后插入要插入的节点
		如果插入的是页面中已有的节点，相当于剪切
父级节点.insertBefore(要插入的节点，被插入的节点)
	作用:在父级节点下，把要插入的节点，插入到被插入的节点前
		如果插入的是页面已有节点，相当于剪切
		被插入的节点一定要是父级节点下的节点，否则会报错
	例子：for(var i=0;i<10;i++){
			var div = document.createElement('div');
			div.innerHTML = i;
			div.style.cssText = 'width:100px;height:100px;float:left;margin-right:5px;border:1px solid #000';
			div.onclick = function(){
				alert(1);
			}
			document.body.appendChild(div);
		}
父级节点.removeChild(要删除的节点)
	作用：删除父级节点下要删除的节点
		注意：要删除的节点必须在父级节点下，否则会报错
父级节点.replaceChild(要替换的节点，被替换的节点)
	作用：在父级节点下，用要替换的节点，替换被替换的节点
		注意：被替换的节点一定要在父级节点下，否则会报错
		 如果要替换的节点是页面中已有的节点，相当于剪切
node.cloneNode(参数)
	作用：克隆节点
	参数：不传参数默认是false
		true:深度克隆，子节点也克隆
		false:只能克隆自身，下面的子节点不克隆
		 	可以克隆：html,css,class...
		 	不能克隆：自定义属性,事件
		var list = document.getElementById('list');
		var lis = list.children;
		lis[0].style.background = 'red';
		lis[0].className = 'abc';
		lis[0].index = 1;
		lis[0].onclick = function(){};
		var li = lis[0].cloneNode()
		console.log(li)
	例子：var inps = document.getElementsByTagName('input');
		var list = document.getElementById('list');
		inps[1].onclick = function(){
			var val = inps[0].value;
			var li = document.createElement('li');
			li.innerHTML = val;
			var span = document.createElement('span');
			span.innerHTML = 'X';
			span.onclick = function(){
				list.removeChild(this.parentNode)
			}
			li.appendChild(span);
			list.appendChild(li);
		}

		