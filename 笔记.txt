1.JS简介：页面组成：
			html -- 结构
			css  -- 样式
			js   -- 行为
	js:JavaScript
	布兰德.艾奇
	js组成：
		ECMAScript(5.1) -- Js基本语法组成
		DOM(文档对象模型) -- 操作页面的方法
		BOM(浏览器对象模型) -- 浏览器相关的方法
	作用：页面交互，修改css样式，与服务器通信
	onclick鼠标点击事件
	alert()调用浏览器默认弹窗
	()：函数或者方法执行
	js行间：<input type="button" style="width:100px;height:100px" value="按钮" onclick="alert('你好')"/>
		优点：直接
		缺点：不方便修改，维护，扩展，复用
	内嵌js：
		优点：方便同一页面复用
		1.推荐script放在body结束标签上边
		2.放在head里，因为代码从上往下逐行解析，页面结构还没加载完，所以获取不到元素
		解决方法：window.onload=function(){
				代码写这里
			}
			window.onload
				页面加载完事件
			；：一行代码结束
	js外链：
		问题同内嵌js
		优点：任意页面可以复用
	变量
		var 变量名 = 数据；
		作用：存储数据，方便数据复用，简化代码
		变量初始化
		 	var 变量名 = 数据；
		 	声明变量
		 		var 变量名；
		 	变量赋值
		 		变量名 = 数据；
			命名规则
			 	1.可以使用字母，数字，下划线_,美元符$
			 	2.第一位不允许是数字
			 	3.不允许用关键字和保留字
			 	4.区分大小写，长度可以任意
			 建议
			 	1.语义化
			 		o - 一个对象
			 		a - 一组元素
			 		n - 数字
			 		str - 字符串
			 		arr - 数组
			 		fn - 函数
			 	2.小驼峰命名法
			 		除了首个单词，后边每个单词首字母大写
	函数
		function 函数名(){}
			 作用：
			 	和变量类似，复用代码
		匿名函数
		 	声明：
		 	1.匿名函数不能直接声明，否则会报错
		 	2.直接写在事件后边
		 	3.var fn = function(){}
		 		调用:
		 			1.事件调用
		 			2.变量名() -- fn()
		有名函数
		 	function 函数名(){}
		 		声明：
		 			1.直接声明
		 		调用：
		 			1.直接调用 -- 函数名()
		 			2.事件调用
		 		注意：函数名后不加括号，不然没点，就执行了 btn.onclick = fn;//函数不加括号，不然还没点，就执行了
 	调用浏览器控制台
		console.log()
	属性操作
		元素.style.样式名 = '值'
		属性操作操作的是行间样式，可读可写
			 		
		1.通过.的方式操作属性 console.log(div.style.width)
			如果样式名不符合命名规范，带- console.log(div.style.background-color)//报错
			解决方法：
			 	1.用['样式名']，注意要加引号 console.log(div.style['background-color'])  
			 	2.去掉-，后边单词首字母大写  console.log(div.style.backgroundColor)
		2.通过[]的方式  console.log(div.style['background-color'])
			注意：
			 复合样式，谷歌和火狐下，获取有区别
	常用属性
		 id
		 class -- className
		 style
		 innerHTML
		 	标签对中间的所有内容，包括子标签，行间属性
		 innerText
		 	标签中的文字内容，不会识别标签
		 style.cssText
	连接符+
		1.两边都是数字，进行加法运算       console.log(1+1)//2
		2.两边都是字符串，进行字符串拼接   console.log('1'+'1')//11
		3.有一边是字符串，就进行字符串拼接 console.log(1+'1')//11
		如果两边有变量，先转成变量存的数据类型，再按照上述执行
	if条件判断
		1.if(判断条件){
			 如果判断条件为真，执行这里的代码
		}
		2.if(判断条件){
			 如果判断条件为真，执行的代码
		}else{
			如果判断条件为假，执行的代码
		}
		3.if(判断条件1){
			如果判断条件1为真，执行的代码
		}else if(判断条件2){
			 如果判断条件2为真，执行的代码
		}else{
			判断条件1和条件2都为假，执行的代码
		}
		布尔值boolean：
			真            假
			true    false
		==:比较两边的值是否相等，相等返回真，不等返回假
		数组
			作用：储存多个数据
			var arr = [];
			1.值与值之间用逗号分隔，注意最后一位后边别加逗号
			2.数组下标数字从0开始,取值arr[0]
			3.length,数据的个数,arr.length,最后一位arr[arr.length-1]
2.获取元素
	 css选择器
		id -- #
		class -- .
		标签名 -- div
	js选择器
		1.id方式
			document.getElementById(''id名称')
		2.class方式
			document.getElementsByClassName('class名')
			元素.getElementsByClassName('class名')
			document和元素限制范围，在范围内，获取指定class名的元素
			获取到的是一个集合，类数组，length获取到元素的个数，数字下标取值，如果只有一个元素，也必须加[0]操作元素
		3.标签名方式
			document.getElementsByTagName('标签名')
			元素.getElementsByTagName('标签名')
			document和元素限制范围，在范围内，获取指定标签名的元素
			获取到的是一个集合，类数组，length获取到元素的个数，数字下标取值，如果只有一个元素，也必须加[0]操作元素
	css选择器
		document.querySelector('css选择器')
		元素.querySelector('css选择器')
		获取到的是一个元素，即使通过标签名或者class，应该获取到一组元素，也只能获取到第一个
		 	
		document.querySelectorAll('css选择器')
		元素.querySelectorAll('css选择器')
		获取到的是一组元素，数字下标取值，length
for循环
	for(初始化变量;判断条件;变量改变){
		 重复执行的代码
	}
	过程：
	1.初始化变量 -- 声明变量i,赋值为0（只执行了一次）
	2.判断条件 -- 判断i是否满足条件，i<6成立，才会执行循环里的代码
	3.逐行执行括号里的代码
	4.变量改变 -- i++，i自增1
	5.判断条件
	6.括号里代码执行
	7.变量改变。。。。。
	注意：
	1.判断条件决定了for是否执行，执行多少次
	2.变量一定要改变，不然就死循环了
	
	取余，取模  %
		1.a < b -> a=2,b=4
			a%b = a
			2%4
		2.a > b
			a%b = a/b余下的数
		3.a = b或a是b的整数倍
			a%b = 0
	Math.floor向下取整,Math.ceil向上取整
	for嵌套for，不要用同一变量i控制，分开用i,j
	例子：for(var i=0;i<10;i++){
			console.log('标记')
			for(var j=0;j<10;j++){
				console.log(i,j)
			}
		}
	this
		关键字
		谁调用这个this,this就指向谁
		1.函数外边调用
			指向window
		2.函数内部调用
			a.直接调用
				调用该事件函数的元素。
			b.函数调用
				指向window
	onmouseover	鼠标输入事件
	onmouseout	鼠标输出事件
非空对象下，可以加自定义属性，索引值
	小例子：for(var i=0;i<btns.length;i++){
		//每个input添加自定义属性index，记录i值，在点的时候就可以通过index知道点的是第几个input，就可以找到对应的第几个div显示了
			btns[i].index = i;
			btns[i].onclick = function(){
			//清除所有Input,div的class
				for(var i=0;i<btns.length;i++){
					btns[i].className = '';
					divs[i].className = '';
				}
				//给当前input和对应的div添加class
				this.className = 'active';
				divs[this.index].className = 'show';
			}
		}
		
		var prev = 0;//记录上一个是第几个
		for(var i=0;i<btns.length;i++){
			btns[i].index = i;
			btns[i].onclick = function(){
				//上一次的input和div的class清除
				btns[prev].className = '';
				divs[prev].className = '';
				//给当前input和对应的div添加class
				this.className = 'active';
				divs[this.index].className = 'show';
				//记录上一次点的是第几个
				prev = this.index;
			}
		}
数据类型
	简单数据类型或者基本数据类型
	String - 字符串
		由0个或者多个字符组成的串
		可以用单引号也可以双引号，但是必须成对出现
	Number - 数字
		整数或者小数
	Boolean - 布尔值
		true - 真
		false - 假
	Null - 空
		只有一个值：null
		当声明一个变量，暂时不知道存什么数据类型，可以先设置为null
	Undefined - 未定义	
		只有一个值：undefined
		当声明变量未赋值，默认值为undefined
	复杂数据类型或复合数据类型
	可以由简单数据类型或者复合数据类型组成
	object - 对象
		var arr = []
		var j = {}
		属性 = 值
		attr = value
		键值对
		当属性名不复合命名规范时，带-，加引号'font-size'
		例子：var j = {
				name:'陈斌',
				age:18,
				duixiang:[],
				'font-size':16,
				fontSize:17
			};
			console.log(j.name);
			console.log(j.age);
			console.log(j.duixiang);
			console.log(j['font-size']);
			console.log(j.fontSize);
	<input type="text" />+<input type="text" />=<input type="text" /><input type="button" value="按钮"/>
	input的value，innerHTML都是字符串//1+1=11
	数据类型转换
		一种数据类型转换成另外一种数据类型
		js可以把任意数据类型转换成下列三种数据类型
		string - 字符串
		number - 数字
		boolean - 布尔值
		同时js提供了基本的转换方法
		String(要转换的数据)
		Number(要转换的数据)
		Boolean(要转换的数据)
	Number()
		如果能转成纯数字就转成数字，如果转不成就是NaN
		NaN:not a number
		NaN的数据类型是数字类型
		字符串
			1.纯数字的字符串，转成数字
			2.前边有0,会忽略
			3.前后有空格,会忽略
			4.空字符串,转成0
			5.不是纯数字还有其他字符（40px）,转成NaN
		布尔值
			 true - 1
			 false - 0
		未定义
			undefined - NaN
		空
			null - 0
		对象
			arr
			1.空数组 - 0
			2.非空数组 - NaN
			{}都是NaN
	typeof 数据
		检测数据类型
		注意：返回首字母是小写
		ECMAScript:string字符串  number数字 boolean布尔值  null空  undefined未定义 object对象
		typeof: string字符串  number数字 boolean布尔值  undefined未定义 object对象 function函数（没有null,null是object）
	字符串转数字
		parseInt()
		整数，忽略第一位非数字往后的字符
		parseFloat()
		小数,忽略非数字部分
		1.纯数字的字符串，转成数字
		2.前边有0,会忽略
		3.前后有空格,会忽略
		4.空字符串,转成NaN
		5.不是纯数字还有其他字符（40px）,转成NaN
	转成字符串类型
		String(要转的数据)
		简易转换法：''+任意数据类型	console.log(''+1)
	转成布尔值
		false:0,'',undefined,null,NaN
		简易版：！取反
		!!数据
		数字
		只有0是false,其他都是true
		字符串
		空字符串是false,有字符就是true
		未定义
		undefined - false
		空
		null - false
	NaN
		NaN与任何数据都不相等，包括也不等于自己
	isNaN()
		先调用Number()，然后再判断是否是NaN
		如果是NaN,返回true
		如果不是NaN,返回false
	显示类型转化
		明确调用某种方法把一种数据类型转换成另外一种数据类型
		Number()
		隐式类型转化
		我们没有明确调用数据类型转换的方法，为了系统运算或者拼接，系统偷偷把类型转换了
	小例子（判断是不是整数）
	inps[1].onclick = function(){
		var val = inps[0].value;
		/*
		 * 100.1  100
		Number() - 100.1 -100
		parseInt() - 100 - 100
		parseFloat() - 100.1 - 100
		 * */
		if(parseInt(val) == parseFloat(val)){
			alert('这是整数')
		}else{
			alert('这不整数')
		}
	}
	小例子（找出数组里最大值）
	var arr = [2,3,6,83,68,23,78,5,1];
	var max = arr[0];
	for(var i=1;i<arr.length;i++){
		if(arr[i]>max){
			max = arr[i];
		}
	}
	console.log(max)
	算术运算符
		+ - * / % ++ --
		n++:先赋值，后运算
		++n:先运算，后赋值
	逻辑运算符
		或与非	|| 
		&& 与，并且
		！非，取反
		||:如果前边为真，就返回前边，如果前边为假，就返回后边的
		&&:如果前边为真，返回后边，如果前边为假，返回前边的
		！：非，取反
		?:三目
	关系运算符
		> < >= <= == != === !==
		==:判断两边值是否相等，相等返回true，不等返回false
		===:先判断两边数据类型是否相同，再判断两边值是否相等，数据类型或者值只要一个不相同，就返回false,都相等返回true
		!=:两边值不等返回true,相等返回false
		!==:数据类型，值，只要有一个不同返回true，都相等返回false
	运算符优先级
		() ++ -- * / + - > < == && || =
	a?b:c 三目，三元运算符
		a判断为true,执行b，a为false执行c
		一元运算符
			+ - ++
		二元运算符
			+ - * /
		三元运算符
			？：
		例子：var a = '1';
			console.log(typeof -a)
			var inps = document.getElementsByTagName('input');
			inps[1].onclick = function(){
				var val = Number(inps[0].value);
				val<10?val='0'+val:val=''+val;
				inps[0].value=val;
			}
	 while循环
		 注意：一定要条件改变，不然就死循环
		var i=0;
		while(i<10){
			执行的代码，
			 i++
		}
		var i=0
		for(;i<10;i++){
			 执行的代码
		}
		例子：var n = 1;
			while(n<10){
				n++;
			}
			console.log(n)
	switch(判断条件){
		case 条件1:
		break;
		case 条件2:
		break;
		default:
		break;
	}
	if(n==1){
		alert('n=1')
	}else if(n==2){
		alert('n=2')
	}else{
		alert('都不成立')
	}
	注意：break不写，穿透
	例子：var n=1;
		switch (n){
			case 1:
			alert('n=1')
			break;
			case 2:
			alert('n=2')
			break;
			default:
			alert('都不成立')
			break;
		}
	break
	终止循环
	for循环：break后边的代码不执行，同时跳出循环
	continue
	跳过
	for循环：continue后边的本次循环的代码不执行
	例子:for(var i=0;i<10;i++){
		if(i==5){
			//break;
			continue;
		}
		console.log(i)
		}
		console.log('标记')
	for in
		循环，遍历，迭代
		for(var k in j){}
	函数 function
		作用：复用代码，声明一个函数，把要复用的代码放到函数里，在需要用的时候调用这个函数，里边的代码就会逐行执行
		函数声明式
		function 函数名(){}
		可以先声明再调用，也可以先调用，再声明
		函数表达式
			var fn = function(){}
		必须先声明，后调用
	函数参数
		我们可以给函数里传入一些数据，让函数的执行或者返回结果有一些变化，函数的可用性和扩展性更高
		参数
			由0个或者多个组成，中间用逗号分隔
		形参
		 	1.在函数声明时，定义形参
		 	2.形参只能在函数内部
		 	3.形参相当于在函数内部使用的变量
		 	4.在函数调用时，传入实参，给形参一一对应赋值
		 	5.没有赋值时，默认值是undefined
		 实参
		 	1.在函数调用时候传入
		 	2.一一对应赋值给形参
	arguments
		参数集合，类数组，length,数字下标取值，从0开始
		一般在不定参数时使用,不写形参，只能在函数内部使用
		传入实参时，一一对应赋值给形参，同时会把数据存入arguments里
	例子：var n = 0;
		function fn(){
			for(var i=0;i<arguments.length;i++){
				n+=arguments[i];
			}
			console.log(n)
		}
		fn(1,2,3,4,5,6,7,8,9,11,2,3,5,6,7,8,4,7,89,90);	
	return 函数返回值
		让函数执行的结果有一定的变化，默认值是undefined,可以返回任意数据类型，只能在函数内部使用
		fn()就等于return后边的数据
		作用：
			1.函数执行完返回我们指定的数据
			2.终止函数后边的代码执行
	例子：var uls = document.getElementsByTagName('ul');
		for(var i=0;i<uls.length;i++){
			if(i==0){
				fn(i,'red');
			}else{
				fn(i,'blue');
			}	
		}
		function fn(n,color){
		var lis = uls[n].getElementsByTagName('li');
		for(var i=0;i<lis.length;i++){
			lis[i].onclick = function(){
				for(var i=0;i<lis.length;i++){
					lis[i].style.background = '';
				}
				this.style.background = color;
				}
			}
		}
作用域
	变量和函数起作用的区域，可访问的区域
	全局作用域
		没在函数里声明的变量和函数，就是全局的，也就是全局可用
	函数作用域（局部作用域）
		在函数里声明的变量和函数，只能在该函数里（包括子函数里）访问，函数外不能直接访问
	函数可以套函数声明，一个函数声明在另一个函数内
全局作用域
	在全局声明的变量或者函数，全局可用
函数作用域
	在函数内声明的变量或函数，只能在该函数内(子函数内)使用，不能在函数外直接使用
	例子：function fn(){
			var a = 1;
			function fn1(){
				console.log('函数作用域');
			}
			fn1();//函数内部可以访问
			return fn1;
		}
		console.log(fn()())//函数作用域,函数作用域,undefined
	作用域链
		变量和函数的查找规则
		函数内>形参>全局
	例子：var a=1;
		function fn(a){
			var a=3;
			console.log(a);
		}
		fn(2);	
	window
		js内置对象
		全局var声明变量或者函数一个变量，同时就会在window上创建一个属性名为变量名，值就为变量值	
	一般我们用var声明变量，也可以不用
		首次给一个未定义的变量赋值,系统会自动创建这个变量，但是是全局变量
		但是不推荐，声明变量一定要用var，不然会造成全局污染
	delete 操作符
		作用：删除对象下属性
		用var声明的变量，不能用delete删除
		返回值：
			能删除，返回true
			不能删除，返回false
	例子：a = 1;
		var b=2;
		delete a;
		delete b;
		function fn(){
			var c=3;
			console.log(delete c)
		}
		fn();
		console.dir(window)
	预解析
		js代码在执行之前，会先把var声明的变量和函数，提到当前域的最前边，然后再逐行执行代码
		var 
			a
		函数
			function fn(){}
		执行
			a=1;
			a=2;
			fn=1;
	全局
		var a
		 	a=1
		fn
	fn函数
		var a
		a=2
		a=3
	例子：console.log(a,b,fn)//undefined undefined function fn(){}
		var a=1;
		fn();
		function fn(){}
		var b = 3;
		a = 2;
		fn = 1;
		console.log(a,b,fn)//2 3 1
闭包
	函数套函数声明就是闭包，内部生成闭包空间
	内部函数可以访问外部函数的数据，外部函数不能访问内部函数的数据
	例子：function a(){
			var b = 1;
			function c(){
				b++;
				console.log(b)
			}
			return c;
		}
		var f = a();
		f();//2
		f();//3
函数自执行
		 匿名函数声明后直接执行，就不会报错
	( function(){} )()推荐
	例子：(function (){
			var a = 1;
			a++;
			console.log(a)
		})()
		var lis = document.getElementsByTagName('li');
		for(var i=0;i<lis.length;i++){
			lis[i].index = i;
			lis[i].onclick = function(){					
				console.log(this.index)
			}
			(function(n){
				lis[n].onclick = function(){
					console.log(n)
				}
			})(i)
			~function(n){
				lis[n].onclick = function(){
					console.log(n)
				}
			}(i)
		}
	getComputedStyle(元素)
			 得到的是一个对象
			 得到某个样式，带单位的字符串值,页面渲染后(计算后)的值
			 	getComputedStyle(元素).width
			 注意：复合样式返回的是所有的值	
			 标准浏览器
			 	getComputedStyle(元素)	alert(getComputedStyle(div).width)
			 非标准
			 	元素.currentStyle	alert(div.currentStyle.width)
	获取元素样式值函数
			 obj：元素，object
			 attr：样式,string
	例子：获取元素样式函数封装
		function getStyle(obj,attr){
		//obj.currentStyle在非标准可以获取到对象，布尔值是true，在标准下是undefined，布尔值是false,所以用这个做判断条件区分标准和非标准浏览器
			if(obj.currentStyle){
				//非标准
				return obj.currentStyle[attr];
			}else{
				//标准
				return getComputedStyle(obj)[attr];
			}
		}
		console.log(getStyle(div,'height'))
	例子：获取元素函数封装
		function getById(name){
			return document.getElementById(name);
		}
		function getByClass(name,obj){
			var obj = obj || document;
			return obj.getElementsByClassName(name);
		}
		var div = getById('div');
		var list = getById('list');
		var lis = getByClass('a',list);
		console.log(lis)
	例子：数字炸弹
		var inps = document.getElementsByTagName('input');
		var a;//随机的数字
		var max = 100;
		var min = 0;
		var onOff = false;
		//确认
		inps[1].onclick = function(){
			if(onOff){
				var val = Number(inps[0].value);
				if(val > a){
					max = val;
				}
				if(val < a){
					min = val;
				}
				if(val == a){
					alert('炸了');
				}else{
					alert(min + '~' + max);
				}
			}	
			}
		//开始
		inps[2].onclick = function(){
			onOff = true;
			a = Math.round(Math.random()*100);
		}
		//重置
		inps[3].onclick = function(){
			onOff = false;
			max = 100;
			min = 0;
		}
定时器
	重复执行定时器
		setInterval()
	延时执行定时器
		setTimeout()
	重复执行定时器
	设置定时器
		setInterval(函数，间隔时间)
		参数
			间隔时间
			1秒=1000毫秒
			毫秒，不带单位
		返回值
			数字类型 定时器的编号或者叫Id,从1开始
	关闭定时器	
		clearInterval()
	例子：自动图片切换
	var img = document.getElementById('img');
	var prev = document.getElementById('prev');
	var next = document.getElementById('next');
	var n = 0 ;
	var arr = ['img/0.jpg','img/1.jpg','img/2.jpg','img/3.jpg','img/4.jpg'];
	var box = document.getElementById('box');
	var timer = null;
	var lis = document.getElementsByTagName('li');
	function tab(){
		if(n > arr.length-1){
			n = 0;
		}
		if(n < 0){
			n = arr.length-1;
		}
		for(var i=0;i<lis.length;i++){
			lis[i].className = '';
		}
		lis[n].className = 'active';
		img.src = arr[n];
	}
	next.onclick = function(){
		n++;
		tab();
	}
	prev.onclick = function(){
		n--;
		tab();
	}
	for(var i=0;i<lis.length;i++){
		lis[i].index = i;
		lis[i].onclick = function(){
			n = this.index;
			tab();
		}
	}
	timer = setInterval(function(){
		n++;
		tab();
	},1000);
	box.onmouseover = function(){
		clearInterval(timer);
	}
	box.onmouseout = function(){
		timer = setInterval(function(){
			n++;
			tab();
		},1000);
		console.log(timer)
	}
	例子：运动
	btn.onclick = function(){
			//count目标点位置
			var c = 400;
			//speed速度
			var s = 3;
			timer = setInterval(function(){
				//begin起始位置
				var b = parseFloat(getComputedStyle(box).left);
				var v = b+s;
				//396+3 = 399
				//399+3 = 402
				if(v >= c){
					v = c;
					clearInterval(timer)
				}
				box.style.left = v+'px';
				console.log(box.style.left)
			},20)
	}
时间对象，时间戳
		new Date()
		获取到的是本地时间，时间对象下有一些方法，可以让我们获取或者设置时间
		1970年1月1日00:00:00格林尼治时间
		注意：月从0开始，0是一月，11是十二月
		设置时间对象3种格式
			1.数字，用逗号分隔（年,月,日,时,分,秒）
			2.字符串,月份英文或缩写,首字母大小写都行，用逗号或者空格分隔(月 日 年 时:分:秒)
			3.对象,时间对象
	获取时间
		getFullYear() -- 年
		getMonth()    -- 月（从0开始，0就是一月）
		getDate()     -- 日
		getDay()      -- 星期几（星期一就是1,星期日是0）
		getHours()    -- 小时 
		getMinutes()  -- 分
		getSeconds()  -- 秒
		getMilliseconds()--毫秒
		getTime()     --时间，当前时间距离1970年1月1日00:00:00的毫秒时间差
		var date = new Date();
		console.log(date.getFullYear())
		console.log(date.getMonth())
		console.log(date.getDay())
		console.log(date.getDate())
		console.log(date.getHours())
		console.log(date.getMinutes())
		console.log(date.getSeconds())
		console.log(date.getMilliseconds())
		console.log(date.getTime())
	设置时间
		setFullYear() -- 年
		setMonth()    -- 月（从0开始，0就是一月）
		setDate()     -- 日
		setHours()    -- 小时 
		setMinutes()  -- 分
		setSeconds()  -- 秒
		setMilliseconds()--毫秒
		setTime()     --时间，当前时间距离1970年1月1日00:00:00的毫秒时间差
		var date = new Date();
		date.setFullYear(2015);
		date.setMonth(0);
		date.setDate(1);
		date.setHours(10);
		date.setMinutes(50);
		date.setSeconds(10);
		date.setTime()
	例子：时钟	var imgs = document.getElementsByTagName('img');
			function show(){
				var date = new Date();
			//10:52:02
			var h = date.getHours();
			var m = date.getMinutes();
			var s = date.getSeconds();
			//获取时间拼成我们想要的格式
			var str = two(h)+':'+two(m)+':'+two(s);
			//用我们拼好的时间字符串调整对应图片的数字，时钟就动起来了
			for(var i=0;i<imgs.length;i++){
				//第2和5位是:，所以跳过
				if(i == 2 || i == 5){
					continue;
				}
				imgs[i].src = 'img/'+str.charAt(i)+'.jpg';
			}
			//补0
			function two(n){
				return n<10?'0'+n:''+n;
			}
			console.log(str);
			}
			//初始化
			show();
			//开启定时器，每1秒执行一次
			setInterval(show,1000)
	例子：时间格式化var arr = [2016,10,1,10,1,10];
			//2016年10月1日10时1分10秒
			function fn(arr,n){
				var s = '';
				var n = n || 0;
				//var str = '年月日时分秒';
				var aStr = ['年月日时分秒','-- ::','// ::'];
				for(var i=0;i<arr.length;i++){
					s += arr[i]+aStr[n].charAt(i);
				}
				return s;
			}
			console.log(fn(arr))//2016年10月1日10时1分10秒		